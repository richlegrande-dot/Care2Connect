/**\n * Weighted Scoring System for Jan v2.5 Evaluation Suite\n * \n * Replaces binary pass/fail with graduated scoring that provides\n * granular feedback on field-level performance and overall quality.\n */\n\nexport interface FieldWeights {\n  category: number;\n  urgency: number;\n  goalAmount: number;\n  name: number;\n  missingFields: number;\n}\n\nexport interface FieldScore {\n  field: string;\n  score: number;        // 0.0 - 1.0\n  weight: number;       // Weight applied\n  weighted: number;     // score * weight\n  reason?: string;      // Why this score was given\n}\n\nexport interface WeightedResult {\n  totalScore: number;           // 0.0 - 1.0 weighted average\n  fieldScores: FieldScore[];    // Individual field results\n  passed: boolean;              // totalScore >= threshold\n  threshold: number;            // Pass threshold used\n  gradeLetter: string;          // A, B, C, D, F\n}\n\n// Default field weights (must sum to 1.0)\nexport const DEFAULT_WEIGHTS: FieldWeights = {\n  category: 0.25,      // Category classification is critical\n  urgency: 0.20,       // Urgency affects prioritization \n  goalAmount: 0.25,    // Goal amount drives fundraising\n  name: 0.20,          // Name personalizes the story\n  missingFields: 0.10  // Completeness bonus\n};\n\n// Configurable thresholds\nexport const SCORING_THRESHOLDS = {\n  PASS_THRESHOLD: 0.85,     // Minimum score to \"pass\" \n  GRADE_A_THRESHOLD: 0.90,  // A grade\n  GRADE_B_THRESHOLD: 0.80,  // B grade  \n  GRADE_C_THRESHOLD: 0.70,  // C grade\n  GRADE_D_THRESHOLD: 0.60,  // D grade\n  // Below 0.60 = F grade\n};\n\n/**\n * Scores category field based on exact match vs semantic equivalence\n */\nfunction scoreCategoryField(\n  actual: string | null | undefined,\n  expected: string | null | undefined,\n  normalizedMatch: boolean\n): FieldScore {\n  if (!expected) {\n    return {\n      field: 'category',\n      score: actual ? 0.5 : 1.0,  // Partial credit for extracting something\n      weight: DEFAULT_WEIGHTS.category,\n      weighted: 0,\n      reason: expected ? 'no_expected_category' : 'both_null'\n    };\n  }\n  \n  if (!actual) {\n    return {\n      field: 'category',\n      score: 0.0,\n      weight: DEFAULT_WEIGHTS.category, \n      weighted: 0,\n      reason: 'missing_category'\n    };\n  }\n  \n  if (normalizedMatch) {\n    const exactMatch = actual.toUpperCase() === expected.toUpperCase();\n    return {\n      field: 'category',\n      score: exactMatch ? 1.0 : 0.9,  // Slight penalty for synonym matching\n      weight: DEFAULT_WEIGHTS.category,\n      weighted: 0,\n      reason: exactMatch ? 'exact_match' : 'normalized_match'\n    };\n  }\n  \n  return {\n    field: 'category',\n    score: 0.0,\n    weight: DEFAULT_WEIGHTS.category,\n    weighted: 0,\n    reason: 'category_mismatch'\n  };\n}\n\n/**\n * Scores urgency field with consideration for priority relationships\n */\nfunction scoreUrgencyField(\n  actual: string | null | undefined,\n  expected: string | null | undefined,\n  normalizedMatch: boolean\n): FieldScore {\n  if (!expected) {\n    return {\n      field: 'urgency',\n      score: actual ? 0.5 : 1.0,\n      weight: DEFAULT_WEIGHTS.urgency,\n      weighted: 0,\n      reason: 'no_expected_urgency'\n    };\n  }\n  \n  if (!actual) {\n    return {\n      field: 'urgency',\n      score: 0.0,\n      weight: DEFAULT_WEIGHTS.urgency,\n      weighted: 0,\n      reason: 'missing_urgency'\n    };\n  }\n  \n  if (normalizedMatch) {\n    return {\n      field: 'urgency',\n      score: 1.0,\n      weight: DEFAULT_WEIGHTS.urgency,\n      weighted: 0,\n      reason: 'urgency_match'\n    };\n  }\n  \n  // Partial credit for close urgency levels\n  const urgencyLevels = ['LOW', 'MEDIUM', 'HIGH', 'CRITICAL'];\n  const actualIndex = urgencyLevels.indexOf(actual.toUpperCase());\n  const expectedIndex = urgencyLevels.indexOf(expected.toUpperCase());\n  \n  if (actualIndex >= 0 && expectedIndex >= 0) {\n    const distance = Math.abs(actualIndex - expectedIndex);\n    const score = Math.max(0, 1.0 - (distance * 0.3)); // 30% penalty per level off\n    \n    return {\n      field: 'urgency',\n      score,\n      weight: DEFAULT_WEIGHTS.urgency,\n      weighted: 0,\n      reason: `urgency_close_miss_distance_${distance}`\n    };\n  }\n  \n  return {\n    field: 'urgency',\n    score: 0.0,\n    weight: DEFAULT_WEIGHTS.urgency,\n    weighted: 0,\n    reason: 'urgency_mismatch'\n  };\n}\n\n/**\n * Scores goal amount with tolerance consideration and partial credit\n */\nfunction scoreGoalAmountField(\n  actual: number | null | undefined,\n  expected: number | null | undefined,\n  tolerance: number = 100\n): FieldScore {\n  // Handle null expectations\n  if (expected === null || expected === undefined) {\n    return {\n      field: 'goalAmount',\n      score: actual === null || actual === undefined ? 1.0 : 0.3,\n      weight: DEFAULT_WEIGHTS.goalAmount,\n      weighted: 0,\n      reason: actual ? 'expected_null_got_amount' : 'both_null'\n    };\n  }\n  \n  // Missing actual amount\n  if (actual === null || actual === undefined) {\n    return {\n      field: 'goalAmount',\n      score: 0.0,\n      weight: DEFAULT_WEIGHTS.goalAmount,\n      weighted: 0,\n      reason: 'missing_amount'\n    };\n  }\n  \n  const difference = Math.abs(actual - expected);\n  \n  // Within tolerance = perfect score\n  if (difference <= tolerance) {\n    return {\n      field: 'goalAmount',\n      score: 1.0,\n      weight: DEFAULT_WEIGHTS.goalAmount,\n      weighted: 0,\n      reason: `amount_within_tolerance_${tolerance}`\n    };\n  }\n  \n  // Graduated scoring based on percentage error\n  const percentError = difference / expected;\n  let score = 0.0;\n  let reason = 'amount_mismatch';\n  \n  if (percentError <= 0.05) {        // Within 5%\n    score = 0.9;\n    reason = 'amount_close_5pct';\n  } else if (percentError <= 0.10) { // Within 10%\n    score = 0.8;\n    reason = 'amount_close_10pct';\n  } else if (percentError <= 0.20) { // Within 20%\n    score = 0.6;\n    reason = 'amount_close_20pct';\n  } else if (percentError <= 0.50) { // Within 50%\n    score = 0.3;\n    reason = 'amount_close_50pct';\n  } else {\n    score = 0.0;\n    reason = `amount_far_off_${Math.round(percentError * 100)}pct`;\n  }\n  \n  return {\n    field: 'goalAmount',\n    score,\n    weight: DEFAULT_WEIGHTS.goalAmount,\n    weighted: 0,\n    reason\n  };\n}\n\n/**\n * Scores name field with fuzzy matching consideration\n */\nfunction scoreNameField(\n  actual: string | null | undefined,\n  expected: string | null | undefined,\n  nameComparisonResult: { matches: boolean; reason?: string; cleanedActual?: string | null }\n): FieldScore {\n  // Handle null expectations\n  if (!expected) {\n    return {\n      field: 'name',\n      score: !actual ? 1.0 : 0.2,  // Small penalty for extracting when none expected\n      weight: DEFAULT_WEIGHTS.name,\n      weighted: 0,\n      reason: actual ? 'expected_null_got_name' : 'both_null'\n    };\n  }\n  \n  // Missing name\n  if (!actual) {\n    return {\n      field: 'name',\n      score: 0.0,\n      weight: DEFAULT_WEIGHTS.name,\n      weighted: 0,\n      reason: 'missing_name'\n    };\n  }\n  \n  // Use name comparison result\n  if (nameComparisonResult.matches) {\n    const score = nameComparisonResult.reason === 'exact_match' ? 1.0 : 0.9;\n    return {\n      field: 'name',\n      score,\n      weight: DEFAULT_WEIGHTS.name,\n      weighted: 0,\n      reason: nameComparisonResult.reason || 'name_match'\n    };\n  }\n  \n  // Partial credit for extracting something name-like\n  const cleanedExists = nameComparisonResult.cleanedActual;\n  const score = cleanedExists ? 0.3 : 0.0;  // 30% for extracting cleanable name\n  \n  return {\n    field: 'name',\n    score,\n    weight: DEFAULT_WEIGHTS.name,\n    weighted: 0,\n    reason: nameComparisonResult.reason || 'name_mismatch'\n  };\n}\n\n/**\n * Scores missing fields tracking accuracy\n */\nfunction scoreMissingFieldsField(\n  actualMissing: string[] | undefined,\n  expectedMissing: string[] | undefined\n): FieldScore {\n  // If no missing fields data available, give neutral score\n  if (!actualMissing && !expectedMissing) {\n    return {\n      field: 'missingFields',\n      score: 0.7,  // Neutral\n      weight: DEFAULT_WEIGHTS.missingFields,\n      weighted: 0,\n      reason: 'no_missing_fields_data'\n    };\n  }\n  \n  const actualSet = new Set(actualMissing || []);\n  const expectedSet = new Set(expectedMissing || []);\n  \n  // Calculate Jaccard similarity\n  const intersection = new Set([...actualSet].filter(x => expectedSet.has(x)));\n  const union = new Set([...actualSet, ...expectedSet]);\n  \n  const jaccard = union.size === 0 ? 1.0 : intersection.size / union.size;\n  \n  return {\n    field: 'missingFields',\n    score: jaccard,\n    weight: DEFAULT_WEIGHTS.missingFields,\n    weighted: 0,\n    reason: `jaccard_similarity_${Math.round(jaccard * 100)}pct`\n  };\n}\n\n/**\n * Calculates weighted score for a complete extraction result\n */\nexport function calculateWeightedScore(\n  actualResults: {\n    name?: string | null;\n    category?: string | null;\n    urgencyLevel?: string | null;\n    goalAmount?: number | null;\n    missingFields?: string[];\n  },\n  expectedResults: {\n    name?: string | null;\n    category?: string | null;\n    urgencyLevel?: string | null;\n    goalAmount?: number | null;\n    missingFields?: string[];\n  },\n  options: {\n    tolerance?: number;\n    allowFuzzyName?: boolean;\n    categoriesMatch?: boolean;\n    urgencyMatches?: boolean;\n    nameComparisonResult?: { matches: boolean; reason?: string; cleanedActual?: string | null };\n    customWeights?: Partial<FieldWeights>;\n    passThreshold?: number;\n  } = {}\n): WeightedResult {\n  \n  // Apply custom weights if provided\n  const weights = { ...DEFAULT_WEIGHTS, ...options.customWeights };\n  const threshold = options.passThreshold ?? SCORING_THRESHOLDS.PASS_THRESHOLD;\n  \n  // Calculate individual field scores\n  const fieldScores: FieldScore[] = [\n    scoreCategoryField(\n      actualResults.category,\n      expectedResults.category,\n      options.categoriesMatch ?? false\n    ),\n    scoreUrgencyField(\n      actualResults.urgencyLevel,\n      expectedResults.urgencyLevel, \n      options.urgencyMatches ?? false\n    ),\n    scoreGoalAmountField(\n      actualResults.goalAmount,\n      expectedResults.goalAmount,\n      options.tolerance\n    ),\n    scoreNameField(\n      actualResults.name,\n      expectedResults.name,\n      options.nameComparisonResult ?? { matches: false }\n    ),\n    scoreMissingFieldsField(\n      actualResults.missingFields,\n      expectedResults.missingFields\n    )\n  ];\n  \n  // Apply weights and calculate total\n  for (const fieldScore of fieldScores) {\n    fieldScore.weight = weights[fieldScore.field as keyof FieldWeights] || 0;\n    fieldScore.weighted = fieldScore.score * fieldScore.weight;\n  }\n  \n  const totalScore = fieldScores.reduce((sum, fs) => sum + fs.weighted, 0);\n  \n  // Determine grade letter\n  let gradeLetter = 'F';\n  if (totalScore >= SCORING_THRESHOLDS.GRADE_A_THRESHOLD) gradeLetter = 'A';\n  else if (totalScore >= SCORING_THRESHOLDS.GRADE_B_THRESHOLD) gradeLetter = 'B';\n  else if (totalScore >= SCORING_THRESHOLDS.GRADE_C_THRESHOLD) gradeLetter = 'C';\n  else if (totalScore >= SCORING_THRESHOLDS.GRADE_D_THRESHOLD) gradeLetter = 'D';\n  \n  return {\n    totalScore: Math.round(totalScore * 1000) / 1000,  // Round to 3 decimal places\n    fieldScores,\n    passed: totalScore >= threshold,\n    threshold,\n    gradeLetter\n  };\n}\n\n/**\n * Calculates score distribution statistics across multiple results\n */\nexport function calculateScoreDistribution(results: WeightedResult[]): {\n  mean: number;\n  median: number;\n  p10: number;     // 10th percentile\n  p90: number;     // 90th percentile\n  stdDev: number;\n  histogram: { bucket: string; count: number }[];\n} {\n  if (results.length === 0) {\n    return {\n      mean: 0, median: 0, p10: 0, p90: 0, stdDev: 0,\n      histogram: []\n    };\n  }\n  \n  const scores = results.map(r => r.totalScore).sort((a, b) => a - b);\n  const n = scores.length;\n  \n  // Calculate statistics\n  const mean = scores.reduce((sum, score) => sum + score, 0) / n;\n  const median = n % 2 === 0 ? (scores[n/2-1] + scores[n/2]) / 2 : scores[Math.floor(n/2)];\n  const p10 = scores[Math.floor(n * 0.1)];\n  const p90 = scores[Math.floor(n * 0.9)];\n  \n  const variance = scores.reduce((sum, score) => sum + Math.pow(score - mean, 2), 0) / n;\n  const stdDev = Math.sqrt(variance);\n  \n  // Create histogram buckets\n  const buckets = ['0.0-0.2', '0.2-0.4', '0.4-0.6', '0.6-0.8', '0.8-1.0'];\n  const histogram = buckets.map(bucket => {\n    const [min, max] = bucket.split('-').map(Number);\n    const count = scores.filter(score => score >= min && score < max + 0.001).length;\n    return { bucket, count };\n  });\n  \n  return {\n    mean: Math.round(mean * 1000) / 1000,\n    median: Math.round(median * 1000) / 1000,\n    p10: Math.round(p10 * 1000) / 1000,\n    p90: Math.round(p90 * 1000) / 1000,\n    stdDev: Math.round(stdDev * 1000) / 1000,\n    histogram\n  };\n}"