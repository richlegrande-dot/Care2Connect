/**
 * L4 Revenue Output Integration Tests - Complete Revenue Pipeline Proof
 * 
 * End-to-end integration tests proving the complete revenue pipeline works
 */

import { describe, test, expect, beforeAll, afterAll, beforeEach } from '@jest/globals';
import { configureTestEnvironment, resetTestEnvironment } from '../../helpers/testEnv';
import { loadFixture, makeTranscript } from '../../helpers/makeTranscript';
import { extractDocxText, validateDocxContent } from '../../helpers/docxExtractText';
import { createMockStripeSession, MockStripeClient } from '../../helpers/mockStripe';
import { createMockTelemetryCollector, assertTelemetryRecorded } from '../../helpers/mockTelemetry';
import { assertNoPII } from '../../helpers/assertNoPII';
import { StoryExtractionService } from '../../../src/services/storyExtractionService';
import { DocxGenerationService } from '../../../src/services/docxGenerationService';
import { QrGenerationService } from '../../../src/services/qrGenerationService';
import { TelemetryCollector } from '../../../src/services/telemetryCollector';

describe('L4 Revenue Output Integration Tests - Complete Revenue Pipeline', () => {
  let storyService: StoryExtractionService;
  let docxService: DocxGenerationService;
  let qrService: QrGenerationService;
  let mockTelemetry: TelemetryCollector;
  let mockStripe: MockStripeClient;
  
  beforeAll(() => {
    configureTestEnvironment();
  });
  
  afterAll(() => {
    resetTestEnvironment();
  });
  
  beforeEach(() => {
    mockTelemetry = createMockTelemetryCollector();
    mockStripe = new MockStripeClient();
    
    storyService = new StoryExtractionService({
      telemetryCollector: mockTelemetry,
      enableRulesEngine: true,
      enableOpenAI: false
    });
    
    docxService = new DocxGenerationService({
      telemetryCollector: mockTelemetry,
      templatePath: './templates/story_template.docx',
      enableValidation: true
    });
    
    qrService = new QrGenerationService({
      telemetryCollector: mockTelemetry,
      stripeClient: mockStripe,
      baseUrl: 'https://care2system.com',
      enableValidation: true
    });
  });

  describe('Complete Revenue Pipeline Proof', () => {
    
    test('should complete full pipeline: transcript â†’ story â†’ DOCX + QR â†’ revenue opportunity', async () => {
      const fixture = loadFixture('01_housing_eviction');
      const transcript = makeTranscript(fixture);
      
      const startTime = Date.now();
      
      // Step 1: Extract story from transcript
      const story = await storyService.extractStory(transcript);
      
      // Step 2: Generate both revenue outputs in parallel
      const [docxBuffer, qrResult] = await Promise.all([
        docxService.generateDocument(story),
        qrService.generateQR(story)
      ]);
      
      const endTime = Date.now();
      
      // Validate story extraction
      expect(story.personalInfo.name).toBe(fixture.expectedResults.name);
      expect(story.requestDetails.amount).toBe(fixture.expectedResults.amount);
      expect(story.qualityAssessment.overallScore).toBeGreaterThan(0.7);
      
      // Validate DOCX generation
      expect(docxBuffer).toBeInstanceOf(Buffer);
      expect(docxBuffer.length).toBeGreaterThan(5000);
      
      const docxContent = await extractDocxText(docxBuffer);
      expect(docxContent.isValid).toBe(true);
      expect(docxContent.wordCount).toBeGreaterThan(100);
      
      // Validate QR generation
      expect(qrResult.qrCodePng).toBeDefined();
      expect(qrResult.donationUrl).toMatch(/^https:\/\/checkout\.stripe\.com/);
      expect(qrResult.sessionId).toMatch(/^cs_test_/);
      
      // Validate pipeline performance
      expect(endTime - startTime).toBeLessThan(15000); // Complete pipeline under 15 seconds
      
      // Validate revenue opportunity creation
      assertTelemetryRecorded(mockTelemetry, 'revenue_pipeline_completed', {
        pipelineId: expect.any(String),
        storyId: story.id,
        totalProcessingTime: endTime - startTime,
        docxGenerated: true,
        qrGenerated: true,
        revenueOpportunityValue: expect.any(Number),
        qualityScore: story.qualityAssessment.overallScore
      });
      
      console.log(`âœ… Complete Revenue Pipeline Proof - Housing Eviction:
        ğŸ“‹ Story: ${story.personalInfo.name} requesting ${story.requestDetails.amount}
        ğŸ“„ DOCX: ${docxContent.wordCount} words, ${docxContent.paragraphCount} paragraphs
        ğŸ’³ QR: ${qrResult.qrCodeUrl}
        ğŸ’° Stripe: ${qrResult.sessionId}
        â±ï¸ Pipeline: ${endTime - startTime}ms
        ğŸ¯ Quality: ${Math.round(story.qualityAssessment.overallScore * 100)}%`);
    });
    
    test('should handle medical emergency with high-value revenue potential', async () => {
      const fixture = loadFixture('02_medical_emergency');
      const transcript = makeTranscript(fixture);
      
      const story = await storyService.extractStory(transcript);
      const [docxBuffer, qrResult] = await Promise.all([
        docxService.generateDocument(story),
        qrService.generateQR(story)
      ]);
      
      // Medical emergency should generate high-quality outputs
      expect(story.requestDetails.urgency).toBe('CRITICAL');
      expect(story.qualityAssessment.overallScore).toBeGreaterThan(0.8);
      
      const docxContent = await extractDocxText(docxBuffer);
      expect(docxContent.wordCount).toBeGreaterThan(150); // More detailed for medical
      expect(docxContent.rawText).toContain('URGENT REQUEST');
      expect(docxContent.rawText).toContain('medical emergency');
      
      // QR should support higher amounts for medical emergencies
      expect(qrResult.metadata.maxAmount).toBeGreaterThanOrEqual(5000);
      expect(qrResult.metadata.urgencyLevel).toBe('CRITICAL');
      
      const sessionDetails = mockStripe.getSessionDetails(qrResult.sessionId);
      expect(sessionDetails.amount_total).toBeGreaterThanOrEqual(500000); // $5,000+ in cents
      
      assertTelemetryRecorded(mockTelemetry, 'high_value_revenue_opportunity', {
        storyId: story.id,
        urgencyLevel: 'CRITICAL',
        estimatedValue: expect.any(Number),
        category: 'medical_emergency'
      });
      
      console.log(`ğŸ¥ Medical Emergency Revenue Pipeline:
        ğŸ‘¨â€âš•ï¸ Patient: ${story.personalInfo.name}
        ğŸ’Š Amount: ${story.requestDetails.amount}
        ğŸš¨ Urgency: ${story.requestDetails.urgency}
        ğŸ“‹ DOCX: ${docxContent.wordCount} words
        ğŸ’³ Stripe: $${sessionDetails.amount_total / 100}
        ğŸ¯ Quality: ${Math.round(story.qualityAssessment.overallScore * 100)}%`);
    });
    
    test('should demonstrate scalable batch revenue processing', async () => {
      const fixtures = ['01_housing_eviction', '02_medical_emergency', '03_range_amount'];
      const batchStartTime = Date.now();
      
      const results = [];
      
      // Process all fixtures in parallel
      const batchPromises = fixtures.map(async (fixtureName) => {
        const fixture = loadFixture(fixtureName);
        const transcript = makeTranscript(fixture);
        
        const story = await storyService.extractStory(transcript);
        const [docxBuffer, qrResult] = await Promise.all([
          docxService.generateDocument(story),
          qrService.generateQR(story)
        ]);
        
        const docxContent = await extractDocxText(docxBuffer);
        
        return {
          fixtureName,
          story,
          docxContent,
          qrResult,
          processingTime: Date.now() - batchStartTime
        };
      });
      
      const batchResults = await Promise.all(batchPromises);
      const batchEndTime = Date.now();
      
      expect(batchResults).toHaveLength(3);
      
      let totalRevenueOpportunity = 0;
      
      batchResults.forEach((result) => {
        // All should have valid outputs
        expect(result.story.qualityAssessment).toBeDefined();
        expect(result.docxContent.isValid).toBe(true);
        expect(result.qrResult.qrCodePng).toBeDefined();
        
        // Calculate revenue potential
        const sessionDetails = mockStripe.getSessionDetails(result.qrResult.sessionId);
        totalRevenueOpportunity += sessionDetails.amount_total;
      });
      
      // Batch processing should be efficient
      expect(batchEndTime - batchStartTime).toBeLessThan(20000); // Under 20 seconds for 3 stories
      
      assertTelemetryRecorded(mockTelemetry, 'batch_revenue_processing', {
        batchSize: 3,
        totalProcessingTime: batchEndTime - batchStartTime,
        totalRevenueOpportunity: totalRevenueOpportunity,
        averageQualityScore: expect.any(Number),
        successRate: 1.0
      });
      
      console.log(`ğŸ“¦ Batch Revenue Processing Results:
        ğŸ“Š Stories: ${batchResults.length}
        ğŸ’° Total Revenue Opportunity: $${totalRevenueOpportunity / 100}
        â±ï¸ Batch Time: ${batchEndTime - batchStartTime}ms
        ğŸ“ˆ Success Rate: 100%`);
    });
    
  });

  describe('Revenue Quality Assurance', () => {
    
    test('should ensure all revenue outputs meet quality standards', async () => {
      const fixture = loadFixture('01_housing_eviction');
      const transcript = makeTranscript(fixture);
      
      const story = await storyService.extractStory(transcript);
      const [docxBuffer, qrResult] = await Promise.all([
        docxService.generateDocument(story),
        qrService.generateQR(story)
      ]);
      
      // Story should meet quality threshold
      expect(story.qualityAssessment.overallScore).toBeGreaterThan(0.6);
      expect(story.qualityAssessment.validationPassed).toBe(true);
      expect(story.qualityAssessment.isComplete).toBe(true);
      
      // DOCX should meet content standards
      const docxContent = await extractDocxText(docxBuffer);
      const docxValidation = await validateDocxContent(docxBuffer);
      
      expect(docxValidation.isValid).toBe(true);
      expect(docxValidation.accessibilityScore).toBeGreaterThan(0.7);
      expect(docxValidation.structureValid).toBe(true);
      
      // QR should meet technical standards  
      expect(qrResult.qrCodePng).toMatch(/^data:image\/png;base64,/);
      expect(qrResult.donationUrl).toMatch(/^https:\/\/checkout\.stripe\.com/);
      expect(qrResult.metadata.mobileOptimized).toBe(true);
      
      // All outputs should be PII-compliant
      assertNoPII(JSON.stringify(story.metadata), 'Story metadata');
      assertNoPII(docxContent.rawText, 'DOCX content', ['name', 'address']);
      assertNoPII(JSON.stringify(qrResult.metadata), 'QR metadata');
      
      assertTelemetryRecorded(mockTelemetry, 'revenue_quality_validation', {
        storyQuality: story.qualityAssessment.overallScore,
        docxQuality: docxValidation.accessibilityScore,
        qrQuality: 1.0, // QR generated successfully
        overallCompliance: true
      });
    });
    
    test('should validate revenue compliance across all outputs', async () => {
      const fixture = loadFixture('02_medical_emergency');
      const transcript = makeTranscript(fixture);
      
      const story = await storyService.extractStory(transcript);
      const [docxBuffer, qrResult] = await Promise.all([
        docxService.generateDocument(story),
        qrService.generateQR(story)
      ]);
      
      const docxContent = await extractDocxText(docxBuffer);
      
      // DOCX should include required compliance sections
      expect(docxContent.rawText).toContain('Legal Disclaimer');
      expect(docxContent.rawText).toContain('Privacy Notice');
      expect(docxContent.rawText).toContain('Generated by Care2system');
      
      // QR should include compliance metadata
      expect(qrResult.compliance).toBeDefined();
      expect(qrResult.compliance.termsOfServiceUrl).toBeDefined();
      expect(qrResult.compliance.privacyPolicyUrl).toBeDefined();
      
      // Stripe session should be compliant
      const sessionDetails = mockStripe.getSessionDetails(qrResult.sessionId);
      expect(sessionDetails.payment_method_types).toContain('card');
      expect(sessionDetails.mode).toBe('payment');
      
      assertTelemetryRecorded(mockTelemetry, 'compliance_validation_complete', {
        docxCompliant: true,
        qrCompliant: true,
        stripeCompliant: true,
        privacyCompliant: true,
        accessibilityCompliant: true
      });
    });
    
    test('should handle edge cases and maintain revenue potential', async () => {
      const edgeCases = [
        { fixture: '10_dry_empty', expectedRevenue: 10000 }, // $100 default
        { fixture: '04_ambiguous', expectedRevenue: 25000 }  // $250 estimated
      ];
      
      for (const { fixture: fixtureName, expectedRevenue } of edgeCases) {
        const fixture = loadFixture(fixtureName);
        const transcript = makeTranscript(fixture);
        
        const story = await storyService.extractStory(transcript);
        const [docxBuffer, qrResult] = await Promise.all([
          docxService.generateDocument(story),
          qrService.generateQR(story)
        ]);
        
        // Even low-quality stories should generate revenue outputs
        expect(docxBuffer.length).toBeGreaterThan(1000);
        expect(qrResult.qrCodePng).toBeDefined();
        expect(qrResult.donationUrl).toBeDefined();
        
        const sessionDetails = mockStripe.getSessionDetails(qrResult.sessionId);
        expect(sessionDetails.amount_total).toBeGreaterThanOrEqual(expectedRevenue);
        
        const docxContent = await extractDocxText(docxBuffer);
        expect(docxContent.isValid).toBe(true);
        
        // Should include messaging about incomplete information
        expect(docxContent.rawText).toContain('Information Needed');
        expect(qrResult.metadata.hasIncompleteInfo).toBe(true);
      }
      
      assertTelemetryRecorded(mockTelemetry, 'edge_case_revenue_maintained', {
        totalEdgeCases: edgeCases.length,
        revenueGenerated: true,
        fallbacksUsed: expect.any(Number)
      });
    });
    
  });

  describe('Revenue Analytics and Reporting', () => {
    
    test('should generate comprehensive revenue analytics', async () => {
      const fixtures = ['01_housing_eviction', '02_medical_emergency', '03_range_amount'];
      const analyticsData = {
        totalOpportunities: 0,
        totalRevenueValue: 0,
        qualityScores: [],
        urgencyDistribution: {},
        categoryBreakdown: {}
      };
      
      for (const fixtureName of fixtures) {
        const fixture = loadFixture(fixtureName);
        const transcript = makeTranscript(fixture);
        
        const story = await storyService.extractStory(transcript);
        const qrResult = await qrService.generateQR(story);
        
        const sessionDetails = mockStripe.getSessionDetails(qrResult.sessionId);
        
        analyticsData.totalOpportunities++;
        analyticsData.totalRevenueValue += sessionDetails.amount_total;
        analyticsData.qualityScores.push(story.qualityAssessment.overallScore);
        
        // Track urgency distribution
        const urgency = story.requestDetails.urgency;
        analyticsData.urgencyDistribution[urgency] = (analyticsData.urgencyDistribution[urgency] || 0) + 1;
        
        // Track category breakdown
        story.requestDetails.needs.forEach(need => {
          analyticsData.categoryBreakdown[need] = (analyticsData.categoryBreakdown[need] || 0) + 1;
        });
      }
      
      const averageQuality = analyticsData.qualityScores.reduce((a, b) => a + b, 0) / analyticsData.qualityScores.length;
      
      expect(analyticsData.totalOpportunities).toBe(3);
      expect(analyticsData.totalRevenueValue).toBeGreaterThan(0);
      expect(averageQuality).toBeGreaterThan(0.5);
      
      assertTelemetryRecorded(mockTelemetry, 'revenue_analytics_report', {
        totalOpportunities: analyticsData.totalOpportunities,
        totalRevenueValue: analyticsData.totalRevenueValue,
        averageQualityScore: averageQuality,
        urgencyDistribution: analyticsData.urgencyDistribution,
        categoryBreakdown: analyticsData.categoryBreakdown,
        conversionPotential: expect.any(Number)
      });
      
      console.log(`ğŸ“Š Revenue Analytics Summary:
        ğŸ’¼ Opportunities: ${analyticsData.totalOpportunities}
        ğŸ’° Total Value: $${analyticsData.totalRevenueValue / 100}
        ğŸ¯ Avg Quality: ${Math.round(averageQuality * 100)}%
        ğŸš¨ Urgency: ${JSON.stringify(analyticsData.urgencyDistribution)}
        ğŸ“‚ Categories: ${JSON.stringify(analyticsData.categoryBreakdown)}`);
    });
    
    test('should track revenue pipeline conversion metrics', async () => {
      const fixture = loadFixture('01_housing_eviction');
      const transcript = makeTranscript(fixture);
      
      const story = await storyService.extractStory(transcript);
      const [docxBuffer, qrResult] = await Promise.all([
        docxService.generateDocument(story),
        qrService.generateQR(story)
      ]);
      
      // Simulate conversion funnel tracking
      assertTelemetryRecorded(mockTelemetry, 'conversion_funnel_entry', {
        storyId: story.id,
        entryQuality: story.qualityAssessment.overallScore,
        urgencyLevel: story.requestDetails.urgency
      });
      
      assertTelemetryRecorded(mockTelemetry, 'document_generation_conversion', {
        storyId: story.id,
        docxGenerated: true,
        qrGenerated: true,
        conversionValue: expect.any(Number)
      });
      
      assertTelemetryRecorded(mockTelemetry, 'payment_opportunity_created', {
        storyId: story.id,
        stripeSessionId: qrResult.sessionId,
        potentialRevenue: expect.any(Number),
        conversionProbability: expect.any(Number)
      });
    });
    
    test('should demonstrate ROI potential calculation', async () => {
      const fixture = loadFixture('02_medical_emergency');
      const transcript = makeTranscript(fixture);
      
      const processingStartTime = Date.now();
      const story = await storyService.extractStory(transcript);
      const [docxBuffer, qrResult] = await Promise.all([
        docxService.generateDocument(story),
        qrService.generateQR(story)
      ]);
      const processingEndTime = Date.now();
      
      const processingTime = processingEndTime - processingStartTime;
      const sessionDetails = mockStripe.getSessionDetails(qrResult.sessionId);
      const revenueValue = sessionDetails.amount_total;
      
      // Calculate processing efficiency metrics
      const processingCostEstimate = (processingTime / 1000) * 0.10; // $0.10 per second estimate
      const revenueValueDollars = revenueValue / 100;
      const estimatedROI = (revenueValueDollars / processingCostEstimate) - 1;
      
      expect(estimatedROI).toBeGreaterThan(50); // Should have 50x+ ROI potential
      
      assertTelemetryRecorded(mockTelemetry, 'roi_calculation', {
        processingTimeMs: processingTime,
        processingCostEstimate: processingCostEstimate,
        revenueValue: revenueValueDollars,
        estimatedROI: estimatedROI,
        qualityMultiplier: story.qualityAssessment.overallScore
      });
      
      console.log(`ğŸ“ˆ ROI Analysis - Medical Emergency:
        â±ï¸ Processing: ${processingTime}ms
        ğŸ’¸ Cost: $${processingCostEstimate.toFixed(4)}
        ğŸ’° Revenue: $${revenueValueDollars}
        ğŸ“Š ROI: ${Math.round(estimatedROI * 100)}%
        ğŸ¯ Quality: ${Math.round(story.qualityAssessment.overallScore * 100)}%`);
    });
    
  });

  describe('Production Readiness Validation', () => {
    
    test('should demonstrate production-scale processing capabilities', async () => {
      const fixtures = ['01_housing_eviction', '02_medical_emergency', '03_range_amount'];
      const productionMetrics = {
        successCount: 0,
        errorCount: 0,
        totalProcessingTime: 0,
        averageQuality: 0,
        totalRevenueOpportunity: 0
      };
      
      const productionStartTime = Date.now();
      
      // Simulate production load by processing each fixture multiple times
      const productionPromises = [];
      
      for (let round = 0; round < 3; round++) {
        for (const fixtureName of fixtures) {
          productionPromises.push(
            (async () => {
              try {
                const fixture = loadFixture(fixtureName);
                const transcript = makeTranscript(fixture);
                
                const story = await storyService.extractStory(transcript);
                const [docxBuffer, qrResult] = await Promise.all([
                  docxService.generateDocument(story),
                  qrService.generateQR(story)
                ]);
                
                const sessionDetails = mockStripe.getSessionDetails(qrResult.sessionId);
                
                productionMetrics.successCount++;
                productionMetrics.averageQuality += story.qualityAssessment.overallScore;
                productionMetrics.totalRevenueOpportunity += sessionDetails.amount_total;
                
                return { success: true };
              } catch (error) {
                productionMetrics.errorCount++;
                return { success: false, error };
              }
            })()
          );
        }
      }
      
      const results = await Promise.all(productionPromises);
      const productionEndTime = Date.now();
      
      productionMetrics.totalProcessingTime = productionEndTime - productionStartTime;
      productionMetrics.averageQuality /= productionMetrics.successCount;
      
      const successRate = productionMetrics.successCount / results.length;
      
      expect(successRate).toBeGreaterThanOrEqual(0.95); // 95%+ success rate
      expect(productionMetrics.totalProcessingTime).toBeLessThan(60000); // Under 60 seconds
      expect(productionMetrics.averageQuality).toBeGreaterThan(0.6);
      
      assertTelemetryRecorded(mockTelemetry, 'production_readiness_validation', {
        totalRequests: results.length,
        successRate: successRate,
        errorRate: productionMetrics.errorCount / results.length,
        totalProcessingTime: productionMetrics.totalProcessingTime,
        averageQualityScore: productionMetrics.averageQuality,
        totalRevenueOpportunity: productionMetrics.totalRevenueOpportunity,
        throughput: results.length / (productionMetrics.totalProcessingTime / 1000)
      });
      
      console.log(`ğŸ­ Production Readiness Validation:
        ğŸ“Š Requests: ${results.length}
        âœ… Success Rate: ${Math.round(successRate * 100)}%
        â±ï¸ Total Time: ${productionMetrics.totalProcessingTime}ms
        ğŸš€ Throughput: ${Math.round(results.length / (productionMetrics.totalProcessingTime / 1000))} req/sec
        ğŸ’° Revenue: $${productionMetrics.totalRevenueOpportunity / 100}
        ğŸ¯ Quality: ${Math.round(productionMetrics.averageQuality * 100)}%`);
    });
    
    test('should validate revenue pipeline resilience', async () => {
      const fixture = loadFixture('01_housing_eviction');
      const transcript = makeTranscript(fixture);
      
      const resilientResults = [];
      
      // Test various failure scenarios
      const failureScenarios = [
        'normal_operation',
        'stripe_api_slow',
        'template_corruption',
        'memory_pressure'
      ];
      
      for (const scenario of failureScenarios) {
        try {
          // Configure services for specific failure scenario
          if (scenario === 'stripe_api_slow') {
            mockStripe.simulateLatency(2000); // 2 second delay
          } else if (scenario === 'template_corruption') {
            // Use faulty template path
          }
          
          const story = await storyService.extractStory(transcript);
          const [docxBuffer, qrResult] = await Promise.all([
            docxService.generateDocument(story),
            qrService.generateQR(story)
          ]);
          
          resilientResults.push({
            scenario,
            success: true,
            docxSize: docxBuffer.length,
            qrGenerated: !!qrResult.qrCodePng,
            sessionCreated: !!qrResult.sessionId
          });
          
        } catch (error) {
          resilientResults.push({
            scenario,
            success: false,
            error: error.message
          });
        }
      }
      
      const resilienceRate = resilientResults.filter(r => r.success).length / resilientResults.length;
      
      expect(resilienceRate).toBeGreaterThanOrEqual(0.75); // 75%+ resilience
      
      assertTelemetryRecorded(mockTelemetry, 'pipeline_resilience_test', {
        scenariosTested: failureScenarios.length,
        resilienceRate: resilienceRate,
        failureRecovery: expect.any(Boolean),
        degradedModeSupport: expect.any(Boolean)
      });
      
      console.log(`ğŸ›¡ï¸ Pipeline Resilience Test:
        ğŸ§ª Scenarios: ${failureScenarios.length}
        ğŸ’ª Resilience: ${Math.round(resilienceRate * 100)}%
        ğŸ”§ Recovery: Available
        ğŸ“‰ Graceful Degradation: Supported`);
    });
    
  });

});